import { createLocalConfig } from "@repo/config/contracts/envs/local";
import { getOrDeployContracts } from "../helpers/deploy";
import { ethers, expect } from "hardhat";
import { getStargateNFTErrorsInterface, mineBlocks } from "../helpers/common";
import { createLegacyNodeHolder } from "../helpers";
import { MyERC20, StargateNFT } from "../../typechain-types";
import { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signers";
import { TransactionResponse } from "ethers";

describe("shard12: StargateNFT Base Rewards", () => {
  let stargateNFTContract: StargateNFT;
  let deployer: HardhatEthersSigner;
  let otherAccounts: HardhatEthersSigner[];
  let mockedVthoToken: MyERC20;
  let tx: TransactionResponse;

  beforeEach(async () => {
    const config = createLocalConfig();
    config.DELEGATION_PERIOD_DURATION = 3; // 3 blocks
    config.TOKEN_LEVELS[0].level.maturityBlocks = 3;
    config.TOKEN_LEVELS[0].level.vetAmountRequiredToStake = ethers.parseEther("1");
    const contracts = await getOrDeployContracts({
      forceDeploy: true,
      config,
    });
    stargateNFTContract = contracts.stargateNFTContract;
    deployer = contracts.deployer;
    otherAccounts = contracts.otherAccounts;
    mockedVthoToken = contracts.mockedVthoToken;
  });

  it("should be able to claim generated VTHO rewards generated by the protocol", async () => {
    const user = otherAccounts[0];

    // User stakes and mints an NFT
    tx = await stargateNFTContract.connect(user).stake(1, {
      value: ethers.parseEther("1"),
    });
    await tx.wait();

    const tokenId = Number(await stargateNFTContract.getCurrentTokenId());

    // Now that the user staked his VET he will start accumulating basic VTHO rewards
    const currentBlock = await stargateNFTContract.clock();
    const maturityPeriodEndBlock = await stargateNFTContract.maturityPeriodEndBlock(tokenId);
    await mineBlocks(Number(maturityPeriodEndBlock - currentBlock));

    // In testnet and production the VTHO rewards are directly sent to the contract by the protocol,
    // but here we need to manually mint the rewards to the contract address
    await mockedVthoToken.mint(stargateNFTContract.target, ethers.parseEther("1000000"));

    // User's VTHO balance should be zero before claiming his rewards
    expect(await mockedVthoToken.balanceOf(user.address)).to.equal(ethers.parseEther("0"));

    const timestampWhenUserStaked = await stargateNFTContract.getLastVetGeneratedVthoClaimTimestamp(
      tokenId
    );
    expect(timestampWhenUserStaked).to.not.equal(0);

    // User has rewards to claim
    const rewardsToClaim = await stargateNFTContract.claimableVetGeneratedVtho(tokenId);
    expect(rewardsToClaim).to.not.equal(0);

    // User claims his rewards
    tx = await stargateNFTContract.connect(user).claimVetGeneratedVtho(tokenId);
    await tx.wait();

    const txBlock = await tx.getBlock();
    if (!txBlock) {
      throw new Error("Transaction block not found");
    }

    // Expect that the last claim timestamp is updated
    expect(await stargateNFTContract.getLastVetGeneratedVthoClaimTimestamp(tokenId)).to.equal(
      txBlock.timestamp
    );

    // Expect that claimable rewards are zero after claiming
    expect(await stargateNFTContract.claimableVetGeneratedVtho(tokenId)).to.equal(0);

    // Since the rewards are calculated based on timestamp we need to re-calculate the rewards
    // based on the block timestamp
    const actualRewardsToClaim = await stargateNFTContract.calculateVTHO(
      timestampWhenUserStaked,
      BigInt(txBlock.timestamp),
      ethers.parseEther("1")
    );

    // User's VTHO balance should be the rewards to claim
    expect(await mockedVthoToken.balanceOf(user.address)).to.equal(actualRewardsToClaim.toString());

    // If we wait again a few blocks the rewards should increase and be claimable again
    await mineBlocks(3);
    expect(await stargateNFTContract.claimableVetGeneratedVtho(tokenId)).to.not.equal(0);

    // User claims his rewards again
    const tx2 = await stargateNFTContract.connect(user).claimVetGeneratedVtho(tokenId);
    await tx2.wait();

    const tx2Block = await tx2.getBlock();
    if (!tx2Block) {
      throw new Error("Transaction block not found");
    }

    const newRewardsToClaim = await stargateNFTContract.calculateVTHO(
      BigInt(txBlock.timestamp),
      BigInt(tx2Block.timestamp),
      ethers.parseEther("1")
    );

    // check that vtho increased in the user balance
    expect(await mockedVthoToken.balanceOf(user.address)).to.equal(
      (actualRewardsToClaim + newRewardsToClaim).toString()
    );
  });

  it("when the VTHO generation is stopped, the rewards are calculated based on the end timestamp", async () => {
    // In testnet and production the VTHO rewards are directly sent to the contract by the protocol,
    // but here we need to manually mint the rewards to the contract address
    tx = await mockedVthoToken.mint(stargateNFTContract.target, ethers.parseEther("1000000"));
    await tx.wait();

    const user = otherAccounts[0];

    // console.log("************ level1", await stargateNFTContract.getLevel(1));
    // console.log("************ level2", await stargateNFTContract.getLevel(2));

    // User stakes and mints an NFT - This test does not fail because it keeps the stake from the previous test
    tx = await stargateNFTContract.connect(user).stake(1, {
      value: ethers.parseEther("1"),
    });
    await tx.wait();

    const tokenId = Number(await stargateNFTContract.getCurrentTokenId());

    // let's accumulate some rewards
    await mineBlocks(2);

    const currentTimestamp = await stargateNFTContract.timestamp();

    // Set the VTHO generation end timestamp
    await stargateNFTContract.connect(deployer).pause();
    await stargateNFTContract.setVthoGenerationEndTimestamp(currentTimestamp);
    await stargateNFTContract.connect(deployer).unpause();

    // Check available rewards
    const rewardsToClaim = await stargateNFTContract.claimableVetGeneratedVtho(tokenId);
    expect(rewardsToClaim).to.not.equal(0);

    // if time passes, the rewards should stay the same
    await mineBlocks(2);
    expect(await stargateNFTContract.claimableVetGeneratedVtho(tokenId)).to.equal(rewardsToClaim);

    // User claims his rewards
    tx = await stargateNFTContract.connect(user).claimVetGeneratedVtho(tokenId);
    await tx.wait();
    const txBlock = await tx.getBlock();
    if (!txBlock) {
      throw new Error("Transaction block not found");
    }

    // user should have received the rewards
    expect(await mockedVthoToken.balanceOf(user.address)).to.equal(rewardsToClaim.toString());

    // last claim timestamp should be updated
    expect(await stargateNFTContract.getLastVetGeneratedVthoClaimTimestamp(tokenId)).to.equal(
      txBlock.timestamp
    );

    // Rewards should keep be 0 with time passing after the end timestamp
    await mineBlocks(2);
    expect(await stargateNFTContract.claimableVetGeneratedVtho(tokenId)).to.equal(0);

    // Claiming rewards again should revert and balance should remain the same
    await expect(
      stargateNFTContract.connect(user).claimVetGeneratedVtho(tokenId)
    ).to.be.revertedWithCustomError(
      await getStargateNFTErrorsInterface(),
      "NoBaseVthoRewardsToClaim"
    );
    expect(await mockedVthoToken.balanceOf(user.address)).to.equal(rewardsToClaim.toString());
  });

  it("should be able to claim generated VTHO rewards for migrated NFTs", async () => {
    const user = otherAccounts[0];

    const lvId = 2;

    const legacyNodeId = await createLegacyNodeHolder(lvId, user);
    // wait 1 block to ensure the legacy node is created
    await mineBlocks(1);

    const level = await stargateNFTContract.getLevel(lvId);

    // User stakes and mints an NFT
    tx = await stargateNFTContract.connect(user).migrate(legacyNodeId, {
      value: level.vetAmountRequiredToStake,
    });
    await tx.wait();

    // User should now have a migrated NFT
    expect(await stargateNFTContract.ownerOf(legacyNodeId)).to.equal(user.address);

    // let's accumulate some rewards
    await mineBlocks(2);

    // User should have rewards to claim
    const rewardsToClaim = await stargateNFTContract.claimableVetGeneratedVtho(legacyNodeId);
    expect(rewardsToClaim).to.not.equal(0n);

    const timestampWhenUserStaked = await stargateNFTContract.getLastVetGeneratedVthoClaimTimestamp(
      legacyNodeId
    );

    // User claims his rewards
    tx = await stargateNFTContract.connect(user).claimVetGeneratedVtho(legacyNodeId);
    await tx.wait();
    const txBlock = await tx.getBlock();
    if (!txBlock) {
      throw new Error("Transaction block not found");
    }

    // User should have received the rewards
    expect(await mockedVthoToken.balanceOf(user.address)).to.equal(
      await stargateNFTContract.calculateVTHO(
        timestampWhenUserStaked,
        BigInt(txBlock.timestamp),
        level.vetAmountRequiredToStake
      )
    );

    // Last claim timestamp should be updated
    expect(await stargateNFTContract.getLastVetGeneratedVthoClaimTimestamp(legacyNodeId)).to.equal(
      txBlock.timestamp
    );
  });

  it("should automatically claim pending rewards when unstaking", async () => {
    const user = otherAccounts[0];
    const lvId = 2;
    const level = await stargateNFTContract.getLevel(lvId);

    const legacyNodeId = await createLegacyNodeHolder(lvId, user);
    // wait 1 block to ensure the legacy node is created
    await mineBlocks(1);

    // User stakes and mints an NFT
    tx = await stargateNFTContract.connect(user).migrate(legacyNodeId, {
      value: level.vetAmountRequiredToStake,
      gasLimit: 10_000_000,
    });
    await tx.wait();

    // let's accumulate some rewards
    await mineBlocks(2);

    // Get the timestamp when user staked
    const timestampWhenUserStaked = await stargateNFTContract.getLastVetGeneratedVthoClaimTimestamp(
      legacyNodeId
    );

    // User should have rewards to claim
    const rewardsToClaim = await stargateNFTContract.claimableVetGeneratedVtho(legacyNodeId);
    expect(rewardsToClaim).to.not.equal(0n);

    // User unstakes the NFT
    tx = await stargateNFTContract.connect(user).unstake(legacyNodeId);
    await tx.wait();
    const txBlock = await tx.getBlock();
    if (!txBlock) {
      throw new Error("Transaction block not found");
    }

    // Calculate expected rewards using the same pattern as previous tests
    const expectedRewards = await stargateNFTContract.calculateVTHO(
      timestampWhenUserStaked,
      BigInt(txBlock.timestamp),
      level.vetAmountRequiredToStake
    );

    // User should have received the rewards
    expect(await mockedVthoToken.balanceOf(user.address)).to.equal(expectedRewards.toString());

    // The NFT should be burned
    await expect(stargateNFTContract.ownerOf(legacyNodeId)).to.be.revertedWithCustomError(
      stargateNFTContract,
      "ERC721NonexistentToken"
    );

    // Last claim timestamp should be updated
    expect(await stargateNFTContract.getLastVetGeneratedVthoClaimTimestamp(legacyNodeId)).to.equal(
      0
    );
  });

  it("Every time the NFT is transferred, the pending rewards are claimed", async () => {
    const user = otherAccounts[0];
    const lvId = 2;
    const level = await stargateNFTContract.getLevel(lvId);

    const legacyNodeId = await createLegacyNodeHolder(lvId, user);
    // wait 1 block to ensure the legacy node is created
    await mineBlocks(1);

    // User stakes and mints an NFT
    tx = await stargateNFTContract.connect(user).migrate(legacyNodeId, {
      value: level.vetAmountRequiredToStake,
    });
    await tx.wait();

    const timestampWhenUserStaked = await stargateNFTContract.getLastVetGeneratedVthoClaimTimestamp(
      legacyNodeId
    );

    // let's accumulate some rewards
    await mineBlocks(2);

    // User should have rewards to claim
    expect(await stargateNFTContract.claimableVetGeneratedVtho(legacyNodeId)).to.not.equal(0n);

    // User transfers the NFT to another address
    tx = await stargateNFTContract
      .connect(user)
      .transferFrom(user.address, otherAccounts[1].address, legacyNodeId);
    await tx.wait();

    const txBlock = await tx.getBlock();
    if (!txBlock) {
      throw new Error("Transaction block not found");
    }

    const expectedClaimedRewards = await stargateNFTContract.calculateVTHO(
      timestampWhenUserStaked,
      BigInt(txBlock.timestamp),
      level.vetAmountRequiredToStake
    );

    // Old owner should have received the rewards
    expect(await mockedVthoToken.balanceOf(user.address)).to.equal(
      expectedClaimedRewards.toString()
    );

    // New owners should not have received the rewards
    expect(await mockedVthoToken.balanceOf(otherAccounts[1].address)).to.equal(0n);

    // Last claim timestamp should be updated
    expect(await stargateNFTContract.getLastVetGeneratedVthoClaimTimestamp(legacyNodeId)).to.equal(
      txBlock.timestamp
    );

    // New rewards are now going to the new owner
    await mineBlocks(2);
    tx = await stargateNFTContract.connect(otherAccounts[1]).claimVetGeneratedVtho(legacyNodeId);
    await tx.wait();
    expect(await mockedVthoToken.balanceOf(otherAccounts[1].address)).to.not.equal(0n);
  });

  it("cannot claim rewards of non-existent NFT", async () => {
    await expect(stargateNFTContract.claimVetGeneratedVtho(1000000)).to.be.revertedWithCustomError(
      await getStargateNFTErrorsInterface(),
      "TokenDoesNotExist"
    );
  });

  it("Claim rewards should revert if there are not enough VTHO in the contract", async () => {
    const { stargateNFTContract, otherAccounts, mockedVthoToken } = await getOrDeployContracts({
      forceDeploy: true,
      mintVtho: false,
    });

    const user = otherAccounts[0];
    const lvId = 2;
    const level = await stargateNFTContract.getLevel(lvId);

    const legacyNodeId = await createLegacyNodeHolder(lvId, user);
    // wait 1 block to ensure the legacy node is created
    await mineBlocks(1);

    // User stakes and mints an NFT
    tx = await stargateNFTContract.connect(user).migrate(legacyNodeId, {
      value: level.vetAmountRequiredToStake,
      gasLimit: 10_000_000,
    });
    await tx.wait();

    const timestampWhenUserStaked = await stargateNFTContract.getLastVetGeneratedVthoClaimTimestamp(
      legacyNodeId
    );

    // let's accumulate some rewards
    await mineBlocks(2);

    // User should have rewards to claim
    expect(await stargateNFTContract.claimableVetGeneratedVtho(legacyNodeId)).to.not.equal(0n);

    const balanceBeforeClaim = await mockedVthoToken.balanceOf(user.address);

    await expect(
      stargateNFTContract.connect(user).claimVetGeneratedVtho(legacyNodeId)
    ).to.be.revertedWithCustomError(
      await getStargateNFTErrorsInterface(),
      "InsufficientContractBalance"
    );

    // User should not have received the rewards
    expect(await mockedVthoToken.balanceOf(user.address)).to.equal(balanceBeforeClaim.toString());

    // Last claim timestamp should not be updated
    expect(await stargateNFTContract.getLastVetGeneratedVthoClaimTimestamp(legacyNodeId)).to.equal(
      timestampWhenUserStaked
    );
  });

  it("Default admin should be able to correctly handle the hayabusa hardfork", async () => {
    // When hayabusa hardfork is activated, the VTHO generation will stop, and the VTHO generation end timestamp will be set to the block number of the hardfork.
    // Since VTHO generation is calculated based on timestamp, instead of block number, we won't be able to know in advance the exact timestamp before
    // the hardfork will happen. For this reason the contract will be paused a few hours before the hardfork, and unpaused after we will know the exact timestamp,
    // to avoid any potential wrong vtho generation end timestamp and rewards calculation.

    const user1 = otherAccounts[0];
    const user2 = otherAccounts[1];
    const lvId = 2;
    const level = await stargateNFTContract.getLevel(lvId);

    // Setup: Users stake and accumulate rewards before the hardfork
    const legacyNodeId1 = await createLegacyNodeHolder(lvId, user1);
    const legacyNodeId2 = await createLegacyNodeHolder(lvId, user2);
    // wait 1 block to ensure the legacy node is created
    await mineBlocks(1);

    // User1 migrates their NFT
    tx = await stargateNFTContract.connect(user1).migrate(legacyNodeId1, {
      value: level.vetAmountRequiredToStake,
    });
    await tx.wait();

    // User2 migrates their NFT
    tx = await stargateNFTContract.connect(user2).migrate(legacyNodeId2, {
      value: level.vetAmountRequiredToStake,
      gasLimit: 10_000_000,
    });
    await tx.wait();

    const user1StakeTimestamp = await stargateNFTContract.getLastVetGeneratedVthoClaimTimestamp(
      legacyNodeId1
    );
    const user2StakeTimestamp = await stargateNFTContract.getLastVetGeneratedVthoClaimTimestamp(
      legacyNodeId2
    );

    // Let some time pass to accumulate rewards
    await mineBlocks(5);

    // Step 1: Contract is paused before the hardfork (simulating a few hours before)
    tx = await stargateNFTContract.connect(deployer).pause();
    await tx.wait();
    expect(await stargateNFTContract.paused()).to.be.true;

    // Step 2: Users should not be able to claim rewards while paused
    await expect(
      stargateNFTContract.connect(user1).claimVetGeneratedVtho(legacyNodeId1)
    ).to.be.revertedWithCustomError(stargateNFTContract, "EnforcedPause");

    await expect(
      stargateNFTContract.connect(user2).claimVetGeneratedVtho(legacyNodeId2)
    ).to.be.revertedWithCustomError(stargateNFTContract, "EnforcedPause");

    // Step 3: Get the current timestamp to simulate the hardfork timestamp
    const hardforkTimestamp = await stargateNFTContract.timestamp();

    // Step 4: Admin sets the VTHO generation end timestamp (simulating hardfork activation)
    tx = await stargateNFTContract
      .connect(deployer)
      .setVthoGenerationEndTimestamp(hardforkTimestamp);
    await tx.wait();
    expect(await stargateNFTContract.vthoGenerationEndTimestamp()).to.equal(hardforkTimestamp);

    // Step 5: Contract is unpaused after setting the timestamp
    tx = await stargateNFTContract.connect(deployer).unpause();
    await tx.wait();
    expect(await stargateNFTContract.paused()).to.be.false;

    // Step 6: Calculate expected rewards up to hardfork timestamp
    const expectedRewardsUser1 = await stargateNFTContract.calculateVTHO(
      user1StakeTimestamp,
      hardforkTimestamp,
      level.vetAmountRequiredToStake
    );

    const expectedRewardsUser2 = await stargateNFTContract.calculateVTHO(
      user2StakeTimestamp,
      hardforkTimestamp,
      level.vetAmountRequiredToStake
    );

    // Step 7: Users can now claim their exact rewards up to the hardfork
    const claimableUser1 = await stargateNFTContract.claimableVetGeneratedVtho(legacyNodeId1);
    const claimableUser2 = await stargateNFTContract.claimableVetGeneratedVtho(legacyNodeId2);

    expect(claimableUser1).to.equal(expectedRewardsUser1);
    expect(claimableUser2).to.equal(expectedRewardsUser2);

    // User1 claims rewards
    tx = await stargateNFTContract.connect(user1).claimVetGeneratedVtho(legacyNodeId1);
    await tx.wait();
    expect(await mockedVthoToken.balanceOf(user1.address)).to.equal(expectedRewardsUser1);

    // User2 claims rewards
    tx = await stargateNFTContract.connect(user2).claimVetGeneratedVtho(legacyNodeId2);
    await tx.wait();
    expect(await mockedVthoToken.balanceOf(user2.address)).to.equal(expectedRewardsUser2);

    // Step 8: After the hardfork, no additional rewards should accumulate
    await mineBlocks(10); // Pass more time

    // Claimable rewards should remain 0 after hardfork
    expect(await stargateNFTContract.claimableVetGeneratedVtho(legacyNodeId1)).to.equal(0);
    expect(await stargateNFTContract.claimableVetGeneratedVtho(legacyNodeId2)).to.equal(0);

    // Attempting to claim again should revert
    await expect(
      stargateNFTContract.connect(user1).claimVetGeneratedVtho(legacyNodeId1)
    ).to.be.revertedWithCustomError(
      await getStargateNFTErrorsInterface(),
      "NoBaseVthoRewardsToClaim"
    );

    await expect(
      stargateNFTContract.connect(user2).claimVetGeneratedVtho(legacyNodeId2)
    ).to.be.revertedWithCustomError(
      await getStargateNFTErrorsInterface(),
      "NoBaseVthoRewardsToClaim"
    );

    // Users' balances should remain unchanged
    expect(await mockedVthoToken.balanceOf(user1.address)).to.equal(expectedRewardsUser1);
    expect(await mockedVthoToken.balanceOf(user2.address)).to.equal(expectedRewardsUser2);
  });
});
